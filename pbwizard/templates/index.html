<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pinball Wizard üßô‚Äç‚ôÇÔ∏è</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 10px;
            touch-action: manipulation;
        }

        /* Layout Containers */
        #app {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px 90px;
        }

        #main-layout {
            display: grid;
            grid-template-columns: minmax(400px, 1fr) 240px minmax(320px, 1fr);
            grid-template-areas:
                "game history settings"
                "game history controls"
                "game history logs";
            gap: 20px;
            margin: 20px 0;
            align-items: start;
        }

        #game-area {
            grid-area: game;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #video-container {
            margin-top: 0;
            border: 2px solid #444;
            display: inline-block;
            max-width: 100%;
            background: #000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        /* Stats */
        #stats-container {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 1em;
        }

        .stat-box {
            background: #1e1e1e;
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #3d3d3d;
            min-width: 80px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .label {
            font-size: 0.7em;
            color: #aaa;
            display: block;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .value {
            font-size: 1.3em;
            font-weight: bold;
            color: #fff;
        }

        /* Score Board */
        .score-board {
            background: #000;
            border: 4px solid #333;
            border-radius: 8px;
            padding: 8px 12px;
            display: inline-flex;
            gap: 4px;
            align-items: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .score-reel {
            width: 28px;
            height: 36px;
            overflow: hidden;
            background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
            border: 1px solid #444;
            border-radius: 4px;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.6);
        }

        .score-strip {
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
        }

        .reel-number {
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            color: #ff6b35;
            text-shadow: 0 0 8px rgba(255, 107, 53, 0.6);
        }

        .score-comma {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            margin: 0 2px;
        }

        /* Tilted Overlay */
        #tilted-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 120px;
            font-weight: bold;
            color: rgba(255, 0, 0, 0.8);
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.9);
            pointer-events: none;
            z-index: 1000;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from {
                transform: translate(-50%, -50%) rotate(-15deg) scale(1);
            }

            to {
                transform: translate(-50%, -50%) rotate(-15deg) scale(1.1);
            }
        }

        /* Shake Animation */
        @keyframes shake-left {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-8px);
            }

            75% {
                transform: translateX(4px);
            }
        }

        @keyframes shake-right {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(8px);
            }

            75% {
                transform: translateX(-4px);
            }
        }

        .shake-left {
            animation: shake-left 0.3s ease-in-out;
        }

        .shake-right {
            animation: shake-right 0.3s ease-in-out;
        }

        /* Controls */
        #controls-container {
            grid-area: controls;
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3d3d3d;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .control-btn {
            flex: 1;
            padding: 10px 15px;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            min-width: 100px;
        }

        .control-btn:hover {
            background-color: #444;
        }

        .control-btn:active {
            background-color: #555;
        }

        .control-btn.active {
            background-color: #4caf50;
        }

        .control-btn:disabled {
            background-color: #222;
            color: #666;
            cursor: not-allowed;
        }

        /* History */
        #history-container {
            grid-area: history;
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3d3d3d;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            min-height: 600px;
            /* Minimum height for vertical chart */
            max-height: 850px;
            /* Prevent it from getting too tall */
            overflow: hidden;
            /* Ensure content doesn't spill */
        }

        #history-container h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #4caf50;
        }

        .sparkline-container {
            flex: 1;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            position: relative;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sparkline-svg {
            width: 100%;
            height: 100%;
        }

        .console {
            grid-area: logs;
            height: 100%;
            overflow: hidden;
        }

        .game-log-container {
            flex: 0 0 auto;
            max-height: 150px;
            overflow-y: auto;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            text-align: left;
        }

        .log-entry {
            padding: 2px 0;
            color: #4caf50;
        }

        /* Physics Controls */
        #physics-controls {
            grid-area: settings;
            background: #1e1e1e;
            border-radius: 8px;
            border: 1px solid #3d3d3d;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            gap: 5px;
            border-bottom: 2px solid #333;
            padding: 10px 10px 0 10px;
            background: #1e1e1e;
            flex-shrink: 0;
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .tab {
            flex: 1;
            padding: 10px;
            background: #2a2a2a;
            border: none;
            border-radius: 5px 5px 0 0;
            color: #aaa;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .tab.active {
            background: #333;
            color: #4caf50;
            border-bottom: 2px solid #4caf50;
        }

        .tab:hover {
            background: #333;
        }

        .group-header {
            font-size: 0.9em;
            color: #4caf50;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-header:hover {
            color: #66bb6a;
        }

        .arrow {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }

        .arrow.rotated {
            transform: rotate(180deg);
        }

        .group-content {
            padding-left: 5px;
        }

        label {
            font-size: 0.9em;
            color: #4caf50;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4caf50;
            cursor: pointer;
            box-shadow: 0 0 4px rgba(76, 175, 80, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4caf50;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 4px rgba(76, 175, 80, 0.5);
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            border-bottom: none;
            margin: 0 0 5px 0;
            padding-bottom: 0;
            color: #ccc;
            text-transform: none;
        }

        /* Connection Status */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 5px;
            order: 1;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-connected {
            background-color: #4caf50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
        }

        .status-disconnected {
            background-color: #f44336;
            box-shadow: 0 0 8px rgba(244, 67, 54, 0.6);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            #main-layout {
                grid-template-columns: 1fr 350px;
                grid-template-areas:
                    "game settings"
                    "controls settings"
                    "history history"
                    "logs logs";
            }

            #history-container {
                height: auto;
                min-height: 250px;
                max-height: 300px;
                /* Cap height on mobile */
            }

            .game-log-container {
                flex-direction: row;
            }

            .connection-status {
                order: 0;
            }
        }

        @media (max-width: 900px) {
            #main-layout {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "game"
                    "controls"
                    "history"
                    "settings"
                    "logs";
            }

            #physics-controls {
                position: static;
            }
        }

        @media (max-width: 690px) {
            #stats-container {
                flex-direction: row;
                flex-wrap: nowrap;
                justify-content: space-between;
                align-items: flex-start;
                gap: 2px;
                width: 100%;
                padding: 0 2px;
                box-sizing: border-box;
            }

            .stat-box {
                flex: 0 1 auto;
                min-width: 0;
            }

            .score-board {
                transform-origin: top left;
                transform: scale(0.6);
                margin-bottom: -15px;
            }

            .label {
                font-size: 0.6em;
            }

            #physics-controls {
                margin: 20px 0;
            }

            #input-area {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                background: rgba(20, 20, 20, 0.95);
                border-top: 1px solid #333;
                padding: 10px 0;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                backdrop-filter: blur(5px);
            }

            #controls-container {
                margin-top: 0;
            }

            #app {
                padding-bottom: 180px;
                /* Ensure enough space for fixed input area */
                margin-bottom: 0;
            }

            #history-container {
                min-height: 200px;
                /* Allow it to be smaller on very small screens */
                max-height: 300px;
            }
        }

        /* Header specific styles */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #4caf50;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .tooltip-score {
            color: #fff;
            font-weight: bold;
            font-size: 0.9em;
        }

        .tooltip-time {
            color: #aaa;
            font-size: 0.8em;
        }

        .axis-label {
            position: absolute;
            font-size: 0.7em;
            color: #666;
            pointer-events: none;
            font-family: 'Courier New', monospace;
        }

        /* Horizontal (Default) - Score on Y */
        .max-score {
            top: 5px;
            left: 5px;
        }

        .min-score {
            bottom: 5px;
            left: 5px;
        }

        /* Vertical - Score on X */
        .max-score.vertical {
            top: auto;
            bottom: -15px;
            right: 0;
            left: auto;
        }

        .min-score.vertical {
            bottom: -15px;
            left: 0;
            top: auto;
        }

        @media (max-width: 690px) {
            .app-header {
                flex-direction: row;
                gap: 10px;
            }

            .header-text {}

            .app-header h1 {
                margin: 5px 0;
                font-size: 1.5em;
            }

            .connection-status {
                font-size: 0.7em;
                margin-top: 5px;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="app-header">
            <div class="header-text">
                <h1>Pinball Wizard üßô‚Äç‚ôÇÔ∏è</h1>
            </div>

            <div class="connection-status" style="font-size: 0.8em; color: #888;">
                <span class="status-dot" :class="connected ? 'status-connected' : 'status-disconnected'"></span>
                [[ connected ? 'Connected' : 'Disconnected' ]]
            </div>

            <div id="stats-container">
                <div class="stat-box" style="background: transparent; border: none; box-shadow: none; padding: 0;">
                    <span class="label" style="margin-bottom: 5px;">SCORE</span>
                    <div class="score-board">
                        <template v-for="(item, index) in scoreReels" :key="index">
                            <div class="score-reel" v-if="item.type === 'digit'">
                                <div class="score-strip" :style="{ transform: `translateY(-${item.value * 36}px)` }">
                                    <div class="reel-number" v-for="n in 10" :key="n">[[ n - 1 ]]</div>
                                </div>
                            </div>
                            <div class="score-comma" v-else>,</div>
                        </template>
                    </div>
                </div>
                <div class="stat-box" style="background: transparent; border: none; box-shadow: none; padding: 0;">
                    <span class="label" style="margin-bottom: 5px;">HIGH SCORE</span>
                    <div class="score-board">
                        <template v-for="(item, index) in highScoreReels" :key="index">
                            <div class="score-reel" v-if="item.type === 'digit'">
                                <div class="score-strip" :style="{ transform: `translateY(-${item.value * 36}px)` }">
                                    <div class="reel-number" v-for="n in 10" :key="n">[[ n - 1 ]]</div>
                                </div>
                            </div>
                            <div class="score-comma" v-else>,</div>
                        </template>
                    </div>
                </div>
                <div class="stat-box" style="background: transparent; border: none; box-shadow: none; padding: 0;">
                    <span class="label" style="margin-bottom: 5px;">BALLS</span>
                    <div class="score-board">
                        <template v-for="(item, index) in ballReels" :key="index">
                            <div class="score-reel" v-if="item.type === 'digit'">
                                <div class="score-strip" :style="{ transform: `translateY(-${item.value * 36}px)` }">
                                    <div class="reel-number" v-for="n in 10" :key="n">[[ n - 1 ]]</div>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>
        </div>

        <div id="main-layout">
            <div id="game-area">
                <!-- Tilted Overlay -->
                <div id="tilted-overlay" v-if="isTilted">TILTED!</div>

                <div id="video-container">
                    <div v-if="stats.is_training"
                        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; color: white;">
                        <h2>TRAINING IN PROGRESS</h2>
                        <p>Step [[ formatNumber(stats.current_step) ]] / [[ formatNumber(stats.total_steps) ]]</p>
                        <div
                            style="width: 60%; height: 8px; background: #555; border-radius: 4px; overflow: hidden; margin-top: 10px;">
                            <div
                                :style="{ width: (stats.training_progress * 100) + '%', height: '100%', background: '#4caf50', transition: 'width 0.3s' }">
                            </div>
                        </div>
                    </div>
                    <img id="video-stream" :src="videoSrc" alt="Pinball Game">
                </div>
            </div>

            <div id="controls-container">
                <div class="control-group">
                    <button class="control-btn" :class="{ active: toggles.ai }" @click="toggleAI">
                        AI: [[ toggles.ai ? 'ON' : 'OFF' ]]
                    </button>
                    <button class="control-btn" :class="{ active: toggles.autoStart }" @click="toggleAutoStart">
                        Auto-Start: [[ toggles.autoStart ? 'ON' : 'OFF' ]]
                    </button>
                </div>
                <div class="control-group">
                    <div style="flex: 1;">
                        <div style="font-size: 0.7em; color: #aaa; margin-bottom: 2px; text-transform: uppercase;">
                            Layout</div>
                        <select v-model="selectedLayout" @change="changeLayout"
                            style="width: 100%; padding: 5px; background: #333; color: #fff; border: 1px solid #444; border-radius: 4px;">
                            <option v-for="layout in layouts" :key="layout.filename" :value="layout.filename">[[
                                layout.name ]]</option>
                        </select>
                    </div>
                </div>
                <div class="control-group">
                    <div style="flex: 1;">
                        <div style="font-size: 0.7em; color: #aaa; margin-bottom: 2px; text-transform: uppercase;">Model
                        </div>
                        <select v-model="selectedModel" @change="loadModel"
                            style="width: 100%; padding: 5px; background: #333; color: #fff; border: 1px solid #444; border-radius: 4px;">
                            <option v-for="model in models" :key="model.filename" :value="model.filename">[[
                                model.filename
                                ]] ([[ model.hash ]])</option>
                        </select>
                    </div>
                </div>
            </div>

            <div id="history-container">
                <h3>Game History</h3>
                <div class="sparkline-container">
                    <div v-if="!showChart"
                        style="flex: 1; display: flex; align-items: center; justify-content: center; color: #666; font-style: italic;">
                        Play at least 3 games to see history
                    </div>
                    <div id="game-history-chart" v-show="showChart" style="width:100%; flex: 1;"></div>
                </div>
            </div>

            <div id="physics-controls">
                <div class="tabs">
                    <button class="tab" :class="{ active: activeTab === 'settings' }"
                        @click="activeTab = 'settings'">Settings</button>
                    <button class="tab" :class="{ active: activeTab === 'training' }"
                        @click="activeTab = 'training'">Training</button>
                </div>

                <!-- Settings Tab -->
                <div v-show="activeTab === 'settings'" class="tab-content">
                    <!-- Ball Physics Group -->
                    <div class="group-header" @click="toggleGroup('ball')">
                        <span>Ball Physics</span>
                        <span class="arrow" :class="{ rotated: expandedGroups.ball }">‚ñº</span>
                    </div>
                    <div v-show="expandedGroups.ball" class="group-content">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Gravity</span>
                                <span>[[ formatNumber(physics.gravity, 1) ]]</span>
                            </div>
                            <input type="range" min="500" max="2000" step="50" v-model.number="physics.gravity"
                                @input="updatePhysics('gravity')">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Friction</span>
                                <span>[[ formatNumber(physics.friction, 3) ]]</span>
                            </div>
                            <input type="range" min="0.990" max="1.000" step="0.001" v-model.number="physics.friction"
                                @input="updatePhysics('friction')">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Restitution (Bounce)</span>
                                <span>[[ formatNumber(physics.restitution, 2) ]]</span>
                            </div>
                            <input type="range" min="0.1" max="1.0" step="0.05" v-model.number="physics.restitution"
                                @input="updatePhysics('restitution')">
                        </div>
                    </div>

                    <!-- Flipper Group -->
                    <div class="group-header" @click="toggleGroup('flipper')">
                        <span>Flipper Mechanics</span>
                        <span class="arrow" :class="{ rotated: expandedGroups.flipper }">‚ñº</span>
                    </div>
                    <div v-show="expandedGroups.flipper" class="group-content">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Speed</span>
                                <span>[[ formatNumber(physics.flipper_speed, 1) ]]</span>
                            </div>
                            <input type="range" min="500" max="3000" step="100" v-model.number="physics.flipper_speed"
                                @input="updatePhysics('flipper_speed')">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Resting Angle</span>
                                <span>[[ physics.flipper_resting_angle ]]</span>
                            </div>
                            <input type="range" v-model.number="physics.flipper_resting_angle" min="-60" max="0"
                                step="1" @input="updatePhysics('flipper_resting_angle')">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Stroke Angle</span>
                                <span>[[ physics.flipper_stroke_angle ]]</span>
                            </div>
                            <input type="range" v-model.number="physics.flipper_stroke_angle" min="10" max="90" step="1"
                                @input="updatePhysics('flipper_stroke_angle')">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Length</span>
                                <span>[[ formatNumber(physics.flipper_length, 2) ]]</span>
                            </div>
                            <input type="range" min="0.1" max="0.3" step="0.01" v-model.number="physics.flipper_length"
                                @input="updatePhysics('flipper_length')">
                        </div>
                    </div>

                    <!-- Tilt Group -->
                    <div class="group-header" @click="toggleGroup('tilt')">
                        <span>Tilt Mechanics</span>
                        <span class="arrow" :class="{ rotated: expandedGroups.tilt }">‚ñº</span>
                    </div>
                    <div v-show="expandedGroups.tilt" class="group-content">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Sensitivity (Threshold)</span>
                                <span>[[ formatNumber(physics.tilt_threshold, 1) ]]</span>
                            </div>
                            <input type="range" min="1" max="20" step="0.5" v-model.number="physics.tilt_threshold"
                                @input="updatePhysics('tilt_threshold')">
                        </div>

                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Nudge Cost</span>
                                <span>[[ formatNumber(physics.nudge_cost, 1) ]]</span>
                            </div>
                            <input type="range" min="0.1" max="10" step="0.1" v-model.number="physics.nudge_cost"
                                @input="updatePhysics('nudge_cost')">
                        </div>

                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Recovery (Decay)</span>
                                <span>[[ formatNumber(physics.tilt_decay, 3) ]]</span>
                            </div>
                            <input type="range" min="0.001" max="0.2" step="0.001" v-model.number="physics.tilt_decay"
                                @input="updatePhysics('tilt_decay')">
                        </div>
                    </div>

                    <div style="margin-top: auto; padding-top: 20px;">
                        <button class="control-btn" @click="resetConfig"
                            style="width: 100%; background-color: #d32f2f;">Reset Physics</button>
                    </div>
                </div>

                <!-- Training Tab -->
                <div v-show="activeTab === 'training'" class="tab-content">
                    <div class="setting-group">
                        <label>Model Name</label>
                        <input type="text" v-model="trainingConfig.modelName"
                            style="width: 80%; padding: 8px; background: #333; color: #fff; border: 1px solid #444; border-radius: 4px; margin-top: 5px;">
                    </div>
                    <div class="setting-group">
                        <label>Timesteps</label>
                        <input type="number" v-model="trainingConfig.timesteps"
                            style="width: 80%; padding: 8px; background: #333; color: #fff; border: 1px solid #444; border-radius: 4px; margin-top: 5px;">
                    </div>
                    <div class="setting-group">
                        <label>Learning Rate</label>
                        <input type="number" v-model="trainingConfig.learningRate" step="0.0001"
                            style="width: 80%; padding: 8px; background: #333; color: #fff; border: 1px solid #444; border-radius: 4px; margin-top: 5px;">
                    </div>

                    <div v-if="stats.is_training" style="margin-top: 15px;">
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9em; color: #ccc;">
                            <span>Progress</span>
                            <span>[[ Math.round(stats.training_progress * 100) ]]%</span>
                        </div>
                        <div style="width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden;">
                            <div
                                :style="{ width: (stats.training_progress * 100) + '%', height: '100%', background: '#4caf50', transition: 'width 0.3s' }">
                            </div>
                        </div>
                        <div style="margin-top: 5px; font-size: 0.8em; color: #aaa; text-align: right;">
                            Steps: [[ formatNumber(stats.current_step) ]] / [[ formatNumber(stats.total_steps) ]]
                        </div>
                    </div>

                    <div style="margin-top: auto; padding-top: 20px; display: flex; gap: 10px;">
                        <button class="control-btn" style="flex: 1; background-color: #4caf50;" @click="startTraining"
                            :disabled="stats.is_training">Start Training</button>
                        <button class="control-btn" style="flex: 1; background-color: #e74c3c;" @click="stopTraining"
                            :disabled="!stats.is_training">Stop</button>
                    </div>
                </div>
            </div>
            <div class="console">
                <div class="game-log-container" ref="logContainer" style="height: 100%; max-height: none;">
                    <div v-for="(log, index) in logs" :key="index" class="log-entry">[[ log ]]</div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, nextTick } = Vue;

        createApp({
            delimiters: ['[[', ']]'],
            setup() {
                const socket = io();
                const connected = ref(false);
                const videoSrc = ref('');
                const logContainer = ref(null);
                const logs = ref([]);
                const activeKeys = reactive(new Set());
                const lastNudgeTime = ref(0);
                const models = ref([]);
                const selectedModel = ref('');
                const debounceTimers = {};

                const addLog = (message) => {
                    const timestamp = new Date().toLocaleTimeString();
                    logs.value.push(`[${timestamp}] ${message}`);
                    if (logs.value.length > 100) logs.value.shift();
                    nextTick(() => {
                        if (logContainer.value) {
                            logContainer.value.scrollTop = logContainer.value.scrollHeight;
                        }
                    });
                };

                const formatToReels = (num, length = 6) => {
                    let str = Math.round(num).toString().padStart(length, '0');
                    if (str.length > length) str = str.slice(-length);

                    const parts = [];
                    for (let i = 0; i < str.length; i++) {
                        parts.push({ type: 'digit', value: parseInt(str[i]) });
                        const dist = str.length - 1 - i;
                        if (dist > 0 && dist % 3 === 0) {
                            parts.push({ type: 'comma', value: ',' });
                        }
                    }
                    return parts;
                };

                const scoreReels = computed(() => formatToReels(stats.score, 6));
                const highScoreReels = computed(() => formatToReels(stats.high_score, 6));
                const ballReels = computed(() => formatToReels(stats.balls, 1));
                const tiltValue = computed(() => stats.tilt_value || 0);
                const isTilted = computed(() => stats.is_tilted || false);
                const tiltColor = computed(() => {
                    const val = tiltValue.value;
                    if (val > 8) return '#ff0000';
                    if (val > 5) return '#ff9800';
                    return '#4caf50';
                });

                const stats = reactive({
                    score: 0,
                    high_score: 0,
                    balls: 0,
                    games_played: 0,
                    timesteps: 0,
                    mean_reward: 0,
                    is_training: false,
                    nudge: null,
                    tilt_value: 0,
                    is_tilted: false,
                    training_progress: 0,
                    current_step: 0,
                    total_steps: 0,
                });

                const physics = reactive({
                    gravity: 1200.0,
                    friction: 0.999,
                    restitution: 0.5,
                    flipper_speed: 1500.0,
                    flipper_resting_angle: -30,
                    flipper_stroke_angle: 50,
                    flipper_length: 0.2,
                    tilt_threshold: 8.0,
                    nudge_cost: 4.0,
                    tilt_decay: 0.05
                });

                const toggles = reactive({
                    ai: true,
                    autoStart: true
                });

                const layouts = ref([]);
                const selectedLayout = ref('default');

                const activeTab = ref('settings');
                const trainingConfig = reactive({
                    modelName: 'ppo_pinball',
                    timesteps: 100000,
                    learningRate: 0.0003
                });

                const gameHistory = ref([]);
                const isVertical = ref(window.innerWidth >= 1200);

                const updateOrientation = () => {
                    isVertical.value = window.innerWidth >= 1200;
                };

                const checkViewportHeight = () => {
                    if (window.innerHeight > 800) {
                        expandedGroups.ball = true;
                        expandedGroups.flipper = true;
                        expandedGroups.tilt = true;
                    }
                };

                const expandedGroups = reactive({
                    ball: false,
                    flipper: false,
                    tilt: false
                });

                const toggleGroup = (group) => {
                    expandedGroups[group] = !expandedGroups[group];
                };

                const formatNumber = (num, decimals = 0) => {
                    if (num === undefined || num === null) return '0';
                    return num.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
                };

                const formatTime = (timestamp) => {
                    if (!timestamp) return '';
                    const date = new Date(timestamp * 1000);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                };

                const reversedHistory = computed(() => {
                    return [...gameHistory.value].reverse();
                });

                const showChart = computed(() => {
                    return gameHistory.value.filter(g => g.type === 'game').length >= 3;
                });

                const { watch } = Vue;
                let chart = null;

                const initChart = () => {
                    if (chart) chart.destroy();

                    const options = {
                        chart: {
                            type: 'area',
                            backgroundColor: 'transparent',
                            margin: [10, 10, 30, 40],
                            inverted: isVertical.value,
                            height: null, // Let container determine height
                            reflow: true,
                            events: {
                                load: function () {
                                    this.reflow();
                                }
                            }
                        },
                        title: { text: null },
                        credits: { enabled: false },
                        xAxis: {
                            visible: true,
                            minPadding: 0,
                            maxPadding: 0,
                            labels: {
                                style: { color: '#aaa' }
                            },
                            gridLineColor: '#333'
                        },
                        yAxis: {
                            title: { text: null },
                            gridLineColor: '#333',
                            labels: {
                                style: { color: '#aaa' }
                            }
                        },
                        plotOptions: {
                            area: {
                                fillColor: {
                                    linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                                    stops: [
                                        [0, 'rgba(76, 175, 80, 0.5)'],
                                        [1, 'rgba(76, 175, 80, 0.1)']
                                    ]
                                },
                                lineColor: '#4caf50',
                                lineWidth: 2,
                                marker: {
                                    enabled: false,
                                    radius: 3,
                                    states: {
                                        hover: { enabled: true }
                                    }
                                },
                                threshold: null
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            style: { color: '#fff' },
                            headerFormat: '',
                            pointFormatter: function () {
                                return `<b>Score: ${this.y.toLocaleString()}</b><br/>Time: ${new Date(this.timestamp * 1000).toLocaleTimeString()}`;
                            }
                        },
                        series: [{
                            name: 'Score',
                            data: []
                        }]
                    };

                    chart = Highcharts.chart('game-history-chart', options);
                    updateChartData();
                };

                const updateChartData = () => {
                    if (!chart) return;

                    if (showChart.value) {
                        nextTick(() => {
                            chart.reflow();
                        });
                    }

                    const seriesData = [];
                    const plotLines = [];

                    gameHistory.value.forEach((g, i) => {
                        if (g.type === 'game') {
                            seriesData.push({
                                x: i,
                                y: g.score,
                                timestamp: g.timestamp,
                                marker: {
                                    enabled: g.is_high_score,
                                    fillColor: '#ffeb3b',
                                    radius: 4
                                }
                            });
                        } else if (g.type === 'model_change') {
                            plotLines.push({
                                color: '#ff9800',
                                width: 2,
                                value: i,
                                zIndex: 5,
                                label: {
                                    text: `<span style="font-size: 8px;">${g.model}</span>`,
                                    rotation: isVertical.value ? 0 : 90,
                                    align: isVertical.value ? 'right' : 'left',
                                    x: isVertical.value ? -5 : 10,
                                    y: isVertical.value ? 10 : 0,
                                    style: {
                                        color: '#ffffff',
                                        fontWeight: 'bold'
                                    }
                                }
                            });
                        }
                    });

                    chart.series[0].setData(seriesData, true, false, false);
                    chart.xAxis[0].update({ plotLines: plotLines });
                };

                watch(gameHistory, () => {
                    updateChartData();
                }, { deep: true });

                watch(isVertical, () => {
                    initChart();
                });

                const handleInput = (key, type) => {
                    if (type === 'down') {
                        if (!activeKeys.has(key)) {
                            activeKeys.add(key);
                            socket.emit('input_event', { key, type: 'down' });
                        }
                    } else {
                        if (activeKeys.has(key)) {
                            activeKeys.delete(key);
                            socket.emit('input_event', { key, type: 'up' });
                        }
                    }
                };

                const updatePhysics = (param) => {
                    if (debounceTimers[param]) clearTimeout(debounceTimers[param]);
                    debounceTimers[param] = setTimeout(() => {
                        socket.emit('update_physics_v2', { [param]: physics[param] });
                        socket.emit('save_physics');
                        delete debounceTimers[param];
                    }, 300);
                };

                const resetConfig = () => {
                    socket.emit('reset_physics');
                };

                const loadModel = () => {
                    if (selectedModel.value) {
                        socket.emit('load_model', { model: selectedModel.value });
                    }
                };

                const toggleAI = () => {
                    socket.emit('toggle_ai', { enabled: !toggles.ai });
                };

                const toggleAutoStart = () => {
                    socket.emit('toggle_auto_start', { enabled: !toggles.autoStart });
                };

                const changeLayout = () => {
                    addLog(`Loading layout: ${selectedLayout.value}`);
                    socket.emit('load_layout_by_name', { name: selectedLayout.value });
                };

                const startTraining = () => {
                    try {
                        addLog(`Starting training: ${trainingConfig.modelName}`);
                        if (!socket.connected) {
                            addLog("Error: Socket not connected");
                            return;
                        }
                        socket.emit('start_training', {
                            model_name: trainingConfig.modelName,
                            total_timesteps: trainingConfig.timesteps,
                            learning_rate: trainingConfig.learningRate
                        });
                    } catch (e) {
                        addLog(`Error starting training: ${e.message}`);
                    }
                };

                const stopTraining = () => {
                    try {
                        addLog('Stopping training...');
                        socket.emit('stop_training');
                    } catch (e) {
                        addLog(`Error stopping training: ${e.message}`);
                    }
                };

                const handleKeydown = (e) => {
                    if (e.repeat) return;
                    if (e.code === 'KeyZ' || e.code === 'Slash' || e.code === 'Space' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                        e.preventDefault();
                        handleInput(e.code, 'down');
                    }
                };

                const handleKeyup = (e) => {
                    if (e.code === 'KeyZ' || e.code === 'Slash' || e.code === 'Space' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                        handleInput(e.code, 'up');
                    }
                };

                onMounted(() => {
                    // ... existing socket setup ...

                    // Initialize chart after a short delay to ensure container is ready
                    setTimeout(initChart, 100);

                    socket.on('connect', () => {
                        connected.value = true;
                        addLog('Connected to server');
                    });

                    socket.on('disconnect', () => {
                        connected.value = false;
                        addLog('Disconnected from server');
                    });

                    socket.on('video_frame', (data) => {
                        videoSrc.value = 'data:image/jpeg;base64,' + data.image;
                    });

                    socket.on('stats', (data) => {
                        Object.assign(stats, data);
                        if (data.game_history) {
                            gameHistory.value = data.game_history;
                        }

                        if (data.nudge && data.nudge.time > lastNudgeTime.value) {
                            lastNudgeTime.value = data.nudge.time;
                            const element = document.getElementById('video-stream');
                            if (element) {
                                element.classList.remove('shake-left', 'shake-right');
                                void element.offsetWidth;

                                if (data.nudge.direction === 'left') {
                                    element.classList.add('shake-left');
                                } else {
                                    element.classList.add('shake-right');
                                }

                                setTimeout(() => {
                                    element.classList.remove('shake-left', 'shake-right');
                                }, 300);
                            }
                        }
                    });

                    socket.on('physics_config_loaded', (config) => {
                        addLog('Physics config loaded');
                        if (config.gravity !== undefined) physics.gravity = config.gravity;
                        if (config.friction !== undefined) physics.friction = config.friction;
                        if (config.restitution !== undefined) physics.restitution = config.restitution;
                        if (config.flipper_speed !== undefined) physics.flipper_speed = config.flipper_speed;
                        if (config.flipper_resting_angle !== undefined) physics.flipper_resting_angle = config.flipper_resting_angle;
                        if (config.flipper_stroke_angle !== undefined) physics.flipper_stroke_angle = config.flipper_stroke_angle;
                        if (config.flipper_length !== undefined) physics.flipper_length = config.flipper_length;
                        if (config.tilt_threshold !== undefined) physics.tilt_threshold = config.tilt_threshold;
                        if (config.nudge_cost !== undefined) physics.nudge_cost = config.nudge_cost;
                        if (config.tilt_decay !== undefined) physics.tilt_decay = config.tilt_decay;

                        if (config.last_model) {
                            selectedModel.value = config.last_model;
                            addLog(`Restored last model selection: ${config.last_model}`);
                        }
                    });

                    socket.on('ai_status', (data) => {
                        toggles.ai = data.enabled;
                        addLog(`AI Enabled: ${data.enabled}`);
                    });

                    socket.on('auto_start_status', (data) => {
                        toggles.autoStart = data.enabled;
                        addLog(`Auto-Start: ${data.enabled}`);
                    });

                    socket.on('layouts_list', (data) => {
                        layouts.value = data;
                        const exists = layouts.value.some(l => l.filename === selectedLayout.value);
                        if (!exists && layouts.value.length > 0) {
                            selectedLayout.value = 'default';
                        }
                    });

                    socket.on('layout_loaded', (data) => {
                        if (data.status === 'success') {
                            addLog('Layout loaded successfully');
                        } else {
                            addLog(`Error loading layout: ${data.message}`);
                        }
                    });

                    socket.emit('get_layouts');
                    socket.emit('get_models');

                    socket.on('log_message', (data) => {
                        addLog(data.message);
                    });

                    socket.on('models_list', (data) => {
                        models.value = data;
                        if (data.length > 0 && !selectedModel.value) {
                            selectedModel.value = data[0].filename;
                        }
                    });

                    socket.on('model_loaded', (data) => {
                        if (data.status === 'success') {
                            addLog(`Model loaded: ${data.model}`);
                        } else {
                            addLog(`Error loading model: ${data.message}`);
                        }
                    });

                    window.addEventListener('keydown', handleKeydown);
                    window.addEventListener('keyup', handleKeyup);
                    window.addEventListener('resize', updateOrientation);

                    window.addEventListener('blur', () => {
                        activeKeys.clear();
                        socket.emit('input_event', { key: 'KeyZ', type: 'up' });
                        socket.emit('input_event', { key: 'Slash', type: 'up' });
                        socket.emit('input_event', { key: 'Space', type: 'up' });
                        socket.emit('input_event', { key: 'ShiftLeft', type: 'up' });
                        socket.emit('input_event', { key: 'ShiftRight', type: 'up' });
                    });
                });

                onUnmounted(() => {
                    if (chart) chart.destroy();
                    window.removeEventListener('keydown', handleKeydown);
                    window.removeEventListener('keyup', handleKeyup);
                    window.removeEventListener('resize', updateOrientation);
                });

                return {
                    connected,
                    videoSrc,
                    stats,
                    physics,
                    toggles,
                    logs,
                    activeKeys,
                    logContainer,
                    formatNumber,
                    handleInput,
                    updatePhysics,
                    resetConfig,
                    toggleAI,
                    toggleAutoStart,
                    layouts,
                    selectedLayout,
                    changeLayout,
                    models,
                    selectedModel,
                    loadModel,
                    scoreReels,
                    highScoreReels,
                    ballReels,
                    tiltValue,
                    isTilted,
                    tiltColor,
                    activeTab,
                    trainingConfig,
                    startTraining,
                    stopTraining,
                    formatTime,
                    gameHistory,
                    reversedHistory,
                    isVertical,
                    expandedGroups,
                    toggleGroup,
                    checkViewportHeight,
                    showChart,
                    formatNumber
                };
            }
        }).mount('#app');
    </script>
</body>

</html>